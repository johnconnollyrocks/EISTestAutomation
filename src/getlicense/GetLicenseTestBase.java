package getlicense;import java.io.IOException;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import org.w3c.dom.Document;import common.EISTestBase;import common.Util;import common.SoapProject;import common.XmlNode;/** * Representation of features and functionality specific to the CEP application. *  * @author Nithya Somasundaram * @version 1.0.0 */public class GetLicenseTestBase extends EISTestBase {	private static final String APP_NAME		= "getlicense";	private static final String APP_BASE_DIR	= "getlicense";		SoapProject soap = new SoapProject();	List <String> compulsoryFields = new ArrayList<>();	List <String> commonFields = new ArrayList<>();	List <String> activeSubFields = new ArrayList<>();	List <String> newFields = new ArrayList<>();	List <String> specialFields = new ArrayList<>();	List <String> compulsoryRelationshipSubfields = new ArrayList<>();		//List <String> RelationshipFromSubfields = new ArrayList<>();	GetLicenseTestBase(String launchDriver) {		//TODO  Change to get APP_BASE_DIR from properties? (currently passed in as JVM arg)		super(APP_NAME, APP_BASE_DIR, launchDriver);	    setup();    }		GetLicenseTestBase(String launchDriver, SoapProject soap) {		//TODO  Change to get APP_BASE_DIR from properties? (currently passed in as JVM arg)		super(APP_NAME, APP_BASE_DIR, launchDriver);	    setup();	    this.soap = soap;    }		/**	 * Default constructor.  It calls the superclass constructor, passing the application's name and directory in the framework's source code hierarchy.	 * @throws IOException 	 */		GetLicenseTestBase() throws IOException {		//TODO  Change to get APP_BASE_DIR from properties? (currently passed in as JVM arg)	    super(APP_NAME, APP_BASE_DIR);	    setup();    }	   	    	/**	 * Configures high-level objects.	 * @see #doSetup()	 */    @Override	protected final void setup() {    	super.setup();    	doSetup();    }    /**	 * Configures high-level CEP-specific objects&#58;<br>	 * &nbsp;&nbsp;&nbsp;&nbsp;instantiates CEP-specific Page objects<br>	 * &nbsp;&nbsp;&nbsp;&nbsp;instantiates CEP-specific Window objects	 * @see #createAppWindows()	 */    private final void doSetup() {    	setEnvironmentVariables();    	//MUST be called after super.setup!!!    }            protected final void setEnvironmentVariables()     {    	//String jobName = testProperties.getConstant("JENKINS_JOB_NAME");    	switch (getEnvironment().trim().toUpperCase())     	{    		case "DEV":    		{    			Util.printDebug("DEV ENV");				if (!GetLicenseConstants.ENDPOINT_URL_DEV.isEmpty()) 				{					setBaseURL(GetLicenseConstants.ENDPOINT_URL_DEV);				}				setAutoUserName(GetLicenseConstants.AUTO_USERNAME_DEV);				setAutoPassword(GetLicenseConstants.AUTO_PASSWORD_DEV);				break;			}    					case "STG":			default:				{				Util.printDebug("STG (or default) ENV");				if (!GetLicenseConstants.ENDPOINT_URL_STG.isEmpty()) 				{					setBaseURL(GetLicenseConstants.ENDPOINT_URL_STG);				}				setAutoUserName(GetLicenseConstants.AUTO_USERNAME_STG);				setAutoPassword(GetLicenseConstants.AUTO_PASSWORD_STG);			}    	}    	    	compulsoryFields.addAll(Arrays.asList ("ProductLine", "Status"));    	    	commonFields.addAll(Arrays.asList ("EUAccountNumber", "EUAccountame", "Deployment", "Description", "LicenseBehavior", "LicenseType", "GroupName", "GroupNumber",     			"PartNumber", "ProductLine", "ProductLineCode", "Seats", "SubscriptionFlag", "UsageType", "UpgradableFlag"));    	    	activeSubFields.addAll(Arrays.asList("ContractNumber", "AssetSubscriptionStartDate", "AssetSubscriptionEndDate", "ContractEndDate", "ContractStartDate"));    	    	newFields.addAll(Arrays.asList("ProductKey", "RegisteredDate", "RecentActivationDate", "LicensingModel", "SubscriptionProgramType"));    	    	specialFields.addAll(Arrays.asList("ContractTerm", "AccountAddress", "ContactFirstName", "ContactLastName", "ContactEmailaddress"));    	    	compulsoryRelationshipSubfields.addAll(Arrays.asList("ProductName", "Seats", "SerialNumber", "Status"));    	    }	@Override	protected void chooseApp() {		// TODO Auto-generated method stub	}	@Override	protected void createAppWindows() {		// TODO Auto-generated method stub			}		//===============================	// NODE & DOC RELATED FUNCTIONS	//===============================		public List<String> getLicenseNodes (String xmlResponse)	{		XmlNode docNode = new XmlNode(xmlResponse);		return docNode.getSubNodes("ns0:License");	}		private String getFirstLicense (String xmlResponse)	{		return getLicenseNodes(xmlResponse).get(0);	}		//==================================	// GET LICENSE IN STRING FUNCTIONS	//==================================				public List<String> getLicenseFields (String xmlLicense)	{		List<String> listOfLicenseFields = new ArrayList<String>();		List<String> listOfLicenseFieldsAndValues = new ArrayList<String>(getLicenseFieldAndValues(xmlLicense));		for (String eachField : listOfLicenseFieldsAndValues)		{			eachField = eachField.split(" ::: ")[0];			listOfLicenseFields.add(eachField);		}		return listOfLicenseFields;	}		public List<String> getLicenseFieldAndValues (String xmlLicense)	{		List<String> listOfLicenseFieldsAndValues = new ArrayList <String>();		String firstLicense = getFirstLicense(xmlLicense);		List<XmlNode> licenseFields = new XmlNode(firstLicense).getSubXmlNodes("ns0:License").get(0).getChildren();		for (int i=0 ; i<licenseFields.size() ; i++)		{			String thisNodeName = licenseFields.get(i).getNodeName();			thisNodeName = thisNodeName.split(":")[1];			String thisNodeValue = licenseFields.get(i).getNodeValue();			listOfLicenseFieldsAndValues.add(thisNodeName+" ::: "+thisNodeValue);		}		return listOfLicenseFieldsAndValues;	}			//===============================	// DEBUG PRINT FIELD FUNCTIONS	//===============================			private void printDebugFields(List<String> listOfFieldsToBeChecked, String xmlLicense, boolean result)	{		boolean originalDebugMode = Util.debugMode; 		if(!result){Util.debugMode = true;}		List<String> listOfActualNodes = new ArrayList<String>(getLicenseFields(xmlLicense));		List<String> listOfActualNodesAndValues = new ArrayList<String>(getLicenseFieldAndValues(xmlLicense));				for (String thisField : listOfFieldsToBeChecked)		{			String strMessage ="";			if(listOfActualNodes.contains(thisField))				{strMessage += "Found: " + listOfActualNodesAndValues.get(listOfActualNodes.indexOf(thisField));}			else				{strMessage += thisField + " not found";}			Util.printDebug(strMessage);		}				Util.debugMode=originalDebugMode;	}		//===============================	// FIELD PRESENCE	//===============================			private boolean verifyFieldsArePresent (List<String> listOfFieldsToBeChecked, String xmlLicense, boolean checkAll)	{		//all = false -> check min = 1. int all = true -> check all in list 		List<String> listOfActual = new ArrayList<String>(getLicenseFields(xmlLicense));		boolean result = false;		if(checkAll) {result = listOfActual.containsAll(listOfFieldsToBeChecked);}		else {			for (int i=0; (i<listOfFieldsToBeChecked.size() && result==false); i++) {				if(listOfActual.contains(listOfFieldsToBeChecked.get(i))) {					result=true;}}}				//debug printed if fails		printDebugFields(listOfFieldsToBeChecked, xmlLicense, result);		return result;	}		private boolean verifyFieldsNotPresent (List<String> listOfFieldsToBeChecked, String xmlLicense, boolean checkAll)	{		List<String> listOfActual = new ArrayList<String>(getLicenseFields(xmlLicense));		boolean result = false;		int actualSize = listOfActual.size();		listOfActual.removeAll(listOfFieldsToBeChecked);		int noOfFieldsPresent = actualSize - listOfActual.size();		if(checkAll) {result = (noOfFieldsPresent == 0) ? true : false;}		else {result = (noOfFieldsPresent < listOfFieldsToBeChecked.size()) ? true : false;} 		//debug printed if fails		printDebugFields(listOfFieldsToBeChecked, xmlLicense, result);		return result; 	}		private boolean verifyFieldPresence (List<String> listOfFieldsToBeChecked, String xmlLicense, boolean isPresent)	{		boolean checkAll = true; //default for check if absent is check all are absent		if(isPresent) {checkAll=false;} //default for check if present is check only one		return verifyFieldPresence(listOfFieldsToBeChecked, xmlLicense, isPresent, checkAll);	}		private boolean verifyFieldPresence (List<String> listOfFieldsToBeChecked, String xmlLicense, boolean isPresent, boolean checkAll)	{		boolean result = true;		if(isPresent){result=verifyFieldsArePresent(listOfFieldsToBeChecked, xmlLicense, checkAll);}		else {result=verifyFieldsNotPresent(listOfFieldsToBeChecked, xmlLicense, checkAll);}		return result;		}		//=====================================	// PUBLIC FIELD VERIFICATION FUNCTIONS	//=====================================		public boolean verifyCompulsoryLicenseFields(String xmlLicense, boolean isPresent)	{		Util.printInfo("Verifying Compulsory Fields presence should be " + (Boolean.toString(isPresent)).toUpperCase());		Util.printInfo("Compulsory Fields: "+ getStringFromListOfStrings(compulsoryFields));		//return verifyFieldsArePresent (compulsoryFields, xmlLicense, true);		if(!isPresent)		{			Util.printInfo(soap.getNodeValue("1:Code", xmlLicense) + " : " +soap.getNodeValue("1:Message", xmlLicense));		}		return verifyFieldPresence(compulsoryFields, xmlLicense, isPresent);	}		public boolean verifyCommonLicenseFields (String xmlLicense)	{		Util.printInfo("Verifying Atleast 1 Common Field");		Util.printInfo("Common Fields: "+ getStringFromListOfStrings(commonFields));		return verifyFieldsArePresent (commonFields, xmlLicense, false);	}		public boolean verifyActiveSubLicenseFields (String xmlLicense, boolean doCheck)	{				String status = soap.getNodeValue("0:Status", xmlLicense);		String subFlag = soap.getNodeValue("0:SubscriptionFlag", xmlLicense);		boolean isPresent = !subFlag.equalsIgnoreCase("False");		Util.printInfo("License Type: " + status + " and Subscription Flag: " + subFlag);		Util.printInfo("Verifying Active Fields presence should be " + (doCheck ? "CHECKED to be present. Acc. to sub. flag  to be " : "") + (Boolean.toString(isPresent)).toUpperCase());		if(doCheck) { isPresent = true;}		Util.printInfo("Active License Fields: "+ getStringFromListOfStrings(activeSubFields));		return verifyFieldPresence(activeSubFields, xmlLicense, isPresent);	}		public boolean  verifyNewLicenseFields (String xmlLicense, boolean isPresent)	{		//verifying extra fields (common to all)		Util.printInfo("Verifying New Get License Field presence should be " + (Boolean.toString(isPresent)).toUpperCase());		Util.printInfo("New Fields: "+ getStringFromListOfStrings(newFields));		return verifyFieldPresence(newFields, xmlLicense, isPresent);	}		public boolean  verifySpecialLicenseFields (String xmlLicense, String partnerType)	{		boolean isPresent = false;				//verifying special fields dependant on partner type		if(partnerType.equalsIgnoreCase("Distributor") || partnerType.equalsIgnoreCase("Reseller")) {isPresent = true;}		else if(partnerType.equalsIgnoreCase("Non")) {isPresent = false;}		else {assertTrue("Partner Type should be specified as 'Distributor' or 'Reseller' or 'Non'", false);}		Util.printInfo("Partner Type: "+ partnerType);		Util.printInfo("Verifying Special Fields presence should be " + (Boolean.toString(isPresent)).toUpperCase());		Util.printInfo("Special Fields: "+ getStringFromListOfStrings(specialFields));		return verifyFieldPresence(specialFields, xmlLicense, isPresent);	}		public boolean verifyRelationshipFields (String xmlLicense)	{		XmlNode licenseNode = new XmlNode(xmlLicense);		boolean check1 = true, check2 = true;		//RELATIONSHIP TO		//verifyFieldPresence		boolean isRelToPresent = verifyRelationshipFieldPresence("RelationshipTo", xmlLicense);		Util.printInfo("Verifying RelationshipTo Field presence: " + (Boolean.toString(isRelToPresent).toUpperCase()));		if(isRelToPresent) {			check1 = verifyRelationshipSubFields(licenseNode.getSubXmlNodes("ns0:RelationshipTo").get(0).getNodeCode());		}		else {Util.printInfo("No verification of Relationship SubFields");}				//RELATIONSHIP FROM		//verifyFieldPresence		System.out.println();		boolean isRelFromPresent = verifyRelationshipFieldPresence("RelationshipFrom", xmlLicense);		Util.printInfo("Verifying RelationshipFrom Field presence: " + (Boolean.toString(isRelFromPresent).toUpperCase()));		if(isRelFromPresent) {			check2 = verifyRelationshipSubFields(licenseNode.getSubXmlNodes("ns0:RelationshipFrom").get(0).getNodeCode());		}		else {Util.printInfo("No verification of Relationship SubFields");}				return (check1 && check2);	}		private boolean verifyRelationshipFieldPresence (String nodeName, String xmlLicense) 	{		XmlNode licenseNode = new XmlNode(xmlLicense);		List<XmlNode> nodes = licenseNode.getSubXmlNodes("ns0:"+nodeName);		if (nodes.size() == 0) {return false;}		else {return nodes.get(0).hasChildren();}	}		private boolean verifyRelationshipSubFields (String xmlRelations)	{		Util.printInfo("Compulsory Relationship SubFields: "+ getStringFromListOfStrings(compulsoryRelationshipSubfields));		List<String> nodeNames = new ArrayList<>();		for (String eachField : compulsoryRelationshipSubfields) { nodeNames.add("ns0:" + eachField); }		XmlNode parentNode = new XmlNode(xmlRelations);		List<XmlNode> allRelationshipNodes = parentNode.getSubXmlNodes("ns0:Relationship");		Util.printInfo("No. of Relationships under Node: " + allRelationshipNodes.size());		for (int i=0;i<allRelationshipNodes.size();i++) 		{			Util.printInfo("Checking Sub Fields under Relationship Node #" + (i+1) + "...");			boolean temp = allRelationshipNodes.get(i).getChildNames().containsAll(nodeNames);			if(!temp) { Util.printInfo("All Compulsory Sub Fields are NOT present under Relationship Node #" + (i+1)); return false; }			else {Util.printInfo("All Compulsory Sub Fields are present under Relationship Node #" + (i+1));}		}		return true;	}	//==========================	// PRINT RESPONSE FUNCTIONS	//==========================	private void displayDivider (char c, int x)	{		for (int i=0; i<x; i++) {System.out.print(c);}		System.out.println();	}		public void displayItem (String strHeading, String strItem)	{		strHeading.toUpperCase();		System.out.println();		displayDivider('*', strHeading.length() + (8*2));		System.out.println("\t" + strHeading);		displayDivider('*', strHeading.length() + (8*2));		System.out.println(strItem);		System.out.println();	}}